{"name":"Goplug","tagline":"GoPlug:  A Go Library to Create and Manage Plugin with Dynamic Loading","body":"# GoPlug \r\n```\r\n< GoPlug >\r\n --------\r\n   \\\r\n    \\   \r\n       _____  -----------------  _____\r\n      |     \\/  ----     ----  \\/     |\r\n       \\  ==/  /    |   |    \\  \\==  /\r\n        \\--/  | ()  |   |()   |  \\--/\r\n          /    \\---/ ___ \\---/    \\\r\n         |         _(===)_         |\r\n        |         (__/--\\__)        |\r\n         |          |_||_|         |\r\n          \\                       /   \r\n```\r\n\r\nGoPlug is a pure Go Plugin library project that provides flexibility, Loose Coupling and modeler approach of Building Software in/around Go. The goal of the project is to provide a simple, fast and a reliable plugin architecture that is independent of the platform. \r\n\r\n[GpPlug GoDoc] (https://godoc.org/github.com/swarvanusg/GoPlug)\r\n\r\n### Version\r\n0.1.0\r\n\r\n### Usage\r\n\r\n#### Step 1 : Get It\r\nTo get the GoPlug install Go and execute the below command \r\n```\r\ngo get github.com/swarvanusg/GoPlug\r\n```\r\n\r\n#### Step 2: Life-cycle\r\nGoPlug plugin life-cycle is quite simple as it consist only three state. \r\n1. **Stopped** : Plugin is not yet started or stopped\r\n2. **Discovered/Installed** : Plugin is discovered and ready to be started\r\n3. **Started/Loaded** : Plugin is started or Loaded for serving request\r\n\r\n###### Plugin Registry\r\nEach of the application creates a Plugin Registry to manage Plugins. Plugin Registry is based on plugin discovery service that provide API to search, load and unload plugin to/from registry.\r\n\r\nAuto discovery service at plugin registry could be disabled resulting plugin to be discovered at loading time.\r\n\r\n###### Plugin\r\nEach plugin makes itself available for the discovery service, and while discovered it is loaded by the application. On a successful loading start() is called and on a successful uploading stop() is called\r\n\r\nLazy start could be enabled to make plugin loaded by explicit call to Plugin Registry rather than at discovery. \r\n\r\n#### Step 3: Use it  \r\n##### Plugin Conf\r\n___\r\nPlugin conf (.pconf) defines the plugin properties. It is created by the Plugins at Plugin startup and loaded by the Application. \r\n###### Example.pconf\r\n```json\r\n    {\r\n        \"Name\" : \"NameOfPlugin\",\r\n        \"NameSpace\" : \"NamespaceOfPlugin\",\r\n        \"Url\" : \"unix://PluginUrl\",\r\n        \"sock\" : \"unixSockLocation.sock\",\r\n        \"LazyLoad\" : false,\r\n    }\r\n```\r\n##### Application That Use Plugins\r\n___\r\nPlugin registry is initialized with the plugin location where it will search for plugin conf **(.pconf)**, along with the Auto Discover setting. If auto discovery is enabled the discover service starts and search for new plugin, while in other case of discovery service not running, plugin gets discovered while loading (via Explicit call to LoadPlugin) if available.\r\n```go\r\n    plugRegConf := GoPlug.PluginRegConf{PluginLocation: \"./PluginLoc\", AutoDiscover: true}\r\n    /* Initialize a Plugin Registry that will search location \"./PluginLoc\" for '.pconf' file */  \r\n    pluginReg, err := GoPlug.PluginRegInit(plugRegConf)\r\n```\r\nLazyload is a feature that prevents auto loading of a plugin when it is discovered. If Plugin is Configured for lazy load plugin should be loaded explicitly when needed by the user.  \r\n\r\n```go\r\n    plugin, err := pluginReg.LoadPlugin(\"name\", \"namespace\")\r\n```\r\nEach plugin is identified by the plugin name and namespace\r\n```go\r\n    plugin := pluginReg.GetPlugin(\"name\", \"namespace\")\r\n```\r\nPlugin can be searched for available methods (registered methods by Plugin implementation)\r\n```go\r\n    methodList := plugin.GetMethods()\r\n```\r\nMethod could be executed by method name \r\n```go\r\n    returnBytes, err := plugin.Execute(methodName, inputBytes)\r\n```\r\nCallback could be registered in Application to receive notification from plugin\r\n```go\r\n    plugin.RegisterCallback(Foo)\r\n    ...\r\n    func Foo(data []byte) {\r\n        // Callback body called on notification from pugin\r\n    }\r\n```\r\nPlugin could be forced to unload or stopped\r\n```go\r\n    err := pluginReg.UnloadPlugin(plugin)\r\n```\r\n##### Plugin Implementation\r\n___\r\nPlugin is initialized with the **Location**, **Name**, **Namespace** (optional), **Url** (optional), **LazyStart conf**, **Activator** and **Stopper**. \r\nThe Plugin location should be same on which Plugin Registry is configured\r\n```go\r\n    config := GoPlug.PluginImplConf{\"PluginLoc\", \"Name\", \"Namespace\", \"unix://URL\", false, activate, stop}\r\n    plugin, err := GoPlug.PluginInit(config)\r\n    ...\r\n    func activate(input []byte) []byte {\r\n        // Called on Activation of the Plugin\r\n    }\r\n    func stop(input []byte) []byte {\r\n        // Called on Deactivation of the Plugin\r\n    }\r\n```\r\nMethod should be registered before starting the plugin\r\n```go\r\nplugin.RegisterMethod(Do)\r\n...\r\nfunc Do(input []byte) []byte {\r\n    // Call on execution of \"Do\" from application\r\n}\r\n```\r\nPlugin start makes the plugin available for the discovery service and to be loaded\r\n```go\r\nplugin.Start()\r\n```\r\nPlugin could notify application using callback. A list of registered callbacks are available at plugins\r\n```go\r\n    //get available callback list\r\n    callbackList := plugin.GetCallbacks()\r\n    ...\r\n    err := plugin.Notify(callbackName, inputBytes)\r\n```\r\nPlugin stop makes the plugin to be stopped and unavailable from the Plugin Reg service. It should be done after plugin is unloaded from the Plugin registry. \r\n```go\r\nplugin.stop()\r\n```\r\n[More ...](https://godoc.org/github.com/swarvanusg/GoPlug#pkg-index)\r\n\r\n#### Step 4: How It Works\r\nPlugins runs a different process that sould be started explicitly. Unix domain socket is used for IPC where the communication is based on HTTP request response model. \r\n###### Step by Step:\r\n1. At start of the Plugin it opens a Unix domain socket and listen for connection\r\n2. Once it initialized it puts the .pconf file in a specific location of Plugin Discovery\r\n3. Plugin Registry discover the .pconf and load the configuration to get the properties and UNIX sock\r\n4. Plugin Registry initialize the Connections using UNIX sock and it loads the Plugin information \r\n5. Http request is made as per the methods Executed over the connection\r\n\r\n### Current Status\r\nGoPlug is unstable and in active development and testing\r\n\r\n### Future Scope\r\nAs GoPlug Plugin are independent process and the communication is based on Unix socket and Http. Plugin could be developed using any programming language. In future GoPlug Plugin Implementation library should be implemented in different languages.  \r\n\r\n### More Information\r\nThis is an early release. I’ve been using it for a while and this is working fine. I like this one pretty well, but no guarantees\r\nthat it won’t change a bit. \r\n\r\nFor Any more info Contact:\r\n```\r\nswarvanusg@gmail.com\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}